#pragma once

#include "RayTracingScene.ush"

#define SAMPLES_PER_PIXEL 50
#define MAX_BOUNCE 100

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint State)
{
	State = State * 747796405 + 2891336453;
	uint result = ((State >> ((State >> 28) + 4)) ^ State) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint State)
{
	return NextRandom(State) / 4294967295.0; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint State)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = 2 * 3.1415926 * RandomValue(State);
	float rho = sqrt(-2 * log(RandomValue(State)));
	return rho * cos(theta);
}

// Calculate a random direction
float3 RandomDirection(inout uint State)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(State);
	float y = RandomValueNormalDistribution(State);
	float z = RandomValueNormalDistribution(State);
	return normalize(float3(x, y, z));
}

float2 RandomPointInCircle(inout uint RngState)
{
	float angle = RandomValue(RngState) * 2 * PI;
	float2 pointOnCircle = float2(cos(angle), sin(angle));
	return pointOnCircle * sqrt(RandomValue(RngState));
}

float ScalarTriple(float3 U, float3 V, float3 W)
{
	return dot(cross(U, V), W);
}

// SceneTest
FHitInfo HitScene(FRay Ray, FQuad Quad)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FSphere Sphere)
{
    FHitInfo HitInfo = (FHitInfo)0;
    
    float3 OffsetRayOrigin = Ray.Origin - Sphere.Position;

    float a = dot(Ray.Direction, Ray.Direction);
    float b = dot(OffsetRayOrigin, Ray.Direction) * 2.0;
    float c = dot(OffsetRayOrigin, OffsetRayOrigin) - Sphere.Radius * Sphere.Radius;
    float Discriminant = b * b - 4.0 * a * c;

    if (Discriminant >= 0)
    {
	    float Dist = (-b - sqrt(Discriminant)) / (2.0 * a);
    	if (Dist >= 0)
    	{
    		HitInfo.bHit = true;
    		HitInfo.HitDistance = Dist;
    		HitInfo.HitPosition = Ray.Origin + Ray.Direction * Dist;
    		HitInfo.HitNormal = normalize(HitInfo.HitPosition - Sphere.Position);
    		HitInfo.Material = Sphere.Material;
    	}
    }
    
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FTriangle Triangle)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FPlane Plane)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FSphere Spheres[NUM_SPHERE])
{
    FHitInfo HitInfo = (FHitInfo)0;
    HitInfo.bHit = false;
    HitInfo.HitDistance = INFINITE_FLOAT;

    for (int i = 0; i < NUM_SPHERE; i++)
    {
        FHitInfo LocalHit = HitScene(Ray, Spheres[i]);
        if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
        {
            HitInfo = LocalHit;
        }
    }
    // for (int i = 0; i < NUM_QUAD; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Quads[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_TRIANGLE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Triangles[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_PLANE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Planes[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    return HitInfo;
}

float Schlick(float Cosine, float IOR)
{
	float R0 = (1.0 - IOR) / (1.0 + IOR);
	R0 = R0 * R0;
	return R0 + (1.0 - R0) * pow((1.0 - Cosine), 5);
}

float3 LightSample(FHitInfo HitInfo, FSphere Spheres[NUM_SPHERE])
{
    float3 Budge = 0;
    float MaxI = 0;
    for (int i = 0; i < NUM_SPHERE; i++)
    {
        if (Spheres[i].Material.Emission > 0)
        {
            float3 Dir = normalize(Spheres[i].Position - HitInfo.HitPosition);
            float Dp = dot(Dir, HitInfo.HitNormal);
            if (Dp > MaxI)
            {
                Budge = Dir;
                MaxI = Dp;
            }
        }
    }
    return Budge * MaxI * 2.0;
}

float3 TraceRay(FRay Ray, inout int RngState, TextureCube SkyCube, SamplerState CubeSampler)
{
    FSphere Spheres[NUM_SPHERE];
    InitScene(Spheres);

    // SkyColor = 0.1 * (1 + Ray.Direction.z ) * float3(0.5, 0.7, 1.0);

	float3 IncomingLight = 0;
	float3 RayColor = 1;
	float3 FinalColor = 1;

    for (int i = 0; i < MAX_BOUNCE; i++)
    {
        FHitInfo HitInfo = HitScene(Ray, Spheres);

        if (HitInfo.bHit)
        {
        	if (HitInfo.Material.Type == MAT_LIGHT)
        	{
        		FinalColor *= HitInfo.Material.Emission * HitInfo.Material.Albedo;
        		break;
        	}
        	if (HitInfo.Material.Type == MAT_DIFFUSE)
        	{
        		Ray.Origin = HitInfo.HitPosition;
        		Ray.Direction = HitInfo.HitNormal + RandomDirection(RngState);
        		FinalColor *= HitInfo.Material.Albedo;
        	}
        	if (HitInfo.Material.Type == MAT_METAL)
        	{
        		float3 DiffuseDir = normalize(HitInfo.HitNormal + RandomDirection(RngState));
        		float3 Reflected = reflect(Ray.Direction, HitInfo.HitNormal);
        		Ray.Origin = HitInfo.HitPosition;
        		Ray.Direction = normalize(lerp(DiffuseDir, Reflected, HitInfo.Material.Fuzziness));
        		FinalColor *= HitInfo.Material.Albedo;
        	}
        	if (HitInfo.Material.Type == MAT_DIALECTRIC)
        	{
        		float3 Reflected = reflect(Ray.Direction, HitInfo.HitNormal);
        		FinalColor = 1;
        		float3 Refracted = 0;
        		float3 OutNormal = 0;
        		float ReflectProb = 0;
        		float Cosine = 0;
        		float Eta;

        		float Dt = dot(Ray.Direction, HitInfo.HitNormal);

        		if (Dt > 0.0)
        		{
        			OutNormal = -HitInfo.HitNormal;
        			Eta = HitInfo.Material.RefractiveIndex;
        			Cosine = Eta * Dt / length(Ray.Direction);
        		}
        		else
        		{
        			OutNormal = HitInfo.HitNormal;
        			Eta = 1.0 / HitInfo.Material.RefractiveIndex;
        			Cosine = -Dt / length(Ray.Direction);
        		}
        		Refracted = refract(Ray.Direction, OutNormal, Eta);
        		if (all(Refracted))
				{
					ReflectProb = Schlick(Cosine, Eta);
				}
				else
				{
					ReflectProb = 1.0;
				}
        		if (RandomValue(RngState) < ReflectProb)
				{
					Ray.Origin = HitInfo.HitPosition;
					Ray.Direction = Reflected;
				}
				else
				{
					Ray.Origin = HitInfo.HitPosition;
					Ray.Direction = Refracted;
				}

        		FinalColor *= HitInfo.Material.Albedo;
        	}
        	float P = max(FinalColor.x, max(FinalColor.y, FinalColor.z));
        	if (RandomValue(RngState) >= P)
			{
				break;
			}
        	FinalColor *= 1.0f / P; 
        }
		else
		{
			float3 SkyColor = TextureCubeSample(SkyCube, CubeSampler, Ray.Direction).rgb;
			FinalColor *= SkyColor;
			break;
		}
    }
    return FinalColor;
}

