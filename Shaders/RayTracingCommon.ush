#pragma once

#include "RayTracingScene.ush"

#define SAMPLES_PER_PIXEL 5
#define MAX_BOUNCE 100

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint State)
{
	State = State * 747796405 + 2891336453;
	uint result = ((State >> ((State >> 28) + 4)) ^ State) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint State)
{
	return NextRandom(State) / 4294967295.0; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint State)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = 2 * 3.1415926 * RandomValue(State);
	float rho = sqrt(-2 * log(RandomValue(State)));
	return rho * cos(theta);
}

// Calculate a random direction
float3 RandomDirection(inout uint State)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(State);
	float y = RandomValueNormalDistribution(State);
	float z = RandomValueNormalDistribution(State);
	return normalize(float3(x, y, z));
}

float2 RandomPointInCircle(inout uint RngState)
{
	float angle = RandomValue(RngState) * 2 * PI;
	float2 pointOnCircle = float2(cos(angle), sin(angle));
	return pointOnCircle * sqrt(RandomValue(RngState));
}

float ScalarTriple(float3 U, float3 V, float3 W)
{
	return dot(cross(U, V), W);
}

// SceneTest
FHitInfo HitScene(FRay Ray, FQuad Quad)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FSphere Sphere)
{
    FHitInfo HitInfo = (FHitInfo)0;
    
    float3 OffsetRayOrigin = Ray.Origin - Sphere.Position;

    float a = dot(Ray.Direction, Ray.Direction);
    float b = dot(OffsetRayOrigin, Ray.Direction) * 2.0;
    float c = dot(OffsetRayOrigin, OffsetRayOrigin) - Sphere.Radius * Sphere.Radius;
    float Discriminant = b * b - 4.0 * a * c;

    if (Discriminant >= 0)
    {
	    float Dist = (-b - sqrt(Discriminant)) / (2.0 * a);
    	if (Dist >= 0)
    	{
    		HitInfo.bHit = true;
    		HitInfo.HitDistance = Dist;
    		HitInfo.HitPosition = Ray.Origin + Ray.Direction * Dist;
    		HitInfo.HitNormal = normalize(HitInfo.HitPosition - Sphere.Position);
    		HitInfo.Material = Sphere.Material;
    	}
    }
    
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, float3 Position, float3 Radius)
{
    FHitInfo HitInfo = (FHitInfo)0;
    
    float3 OffsetRayOrigin = Ray.Origin - Position;

    float a = dot(Ray.Direction, Ray.Direction);
    float b = dot(OffsetRayOrigin, Ray.Direction) * 2.0;
    float c = dot(OffsetRayOrigin, OffsetRayOrigin) - Radius * Radius;
    float Discriminant = b * b - 4.0 * a * c;

    if (Discriminant >= 0)
    {
        float Dist = (-b - sqrt(Discriminant)) / (2.0 * a);
        if (Dist >= 0)
        {
            HitInfo.bHit = true;
            HitInfo.HitDistance = Dist;
            HitInfo.HitPosition = Ray.Origin + Ray.Direction * Dist;
            HitInfo.HitNormal = normalize(HitInfo.HitPosition - Position);
        }
    }
    
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FTriangle Triangle)
{
    FHitInfo HitInfo = (FHitInfo)0;

    // float3 EdgeAB = Triangle.B - Triangle.A;
    // float3 EdgeAC = Triangle.C - Triangle.A;
    // float3 Normal = normalize(cross(EdgeAB, EdgeAC));
    // float3 AO = Ray.Origin - Triangle.A;
    // float3 DAO = cross(AO, Ray.Direction);
    //
    // float Determinant = -dot(Ray.Direction, Normal);
    // float InvDet = 1.0 / Determinant;
    //
    // float Dst = dot(AO, Normal) * InvDet;
    // float U = dot(DAO, EdgeAC) * InvDet;
    // float V = -dot(DAO, EdgeAB) * InvDet;
    // float W = 1 - U - V;
    //
    // HitInfo.bHit = Determinant >= 1E-6 && Dst >= 0 && U >= 0 && V >= 0 && W >= 0;
    // HitInfo.HitDistance = Dst;
    // HitInfo.HitPosition = Ray.Origin + Ray.Direction * Dst;
    // HitInfo.HitNormal = normalize(Triangle.NormalA * W + Triangle.NormalB * U + Triangle.NormalC * V);

	const float EPSILON = 0.0000001;
	float3 Edge1 = Triangle.B - Triangle.A;
	float3 Edge2 = Triangle.C - Triangle.A;
	float3 PVector = cross(Ray.Direction, Edge2);
	float Det = dot(Edge1, PVector);

	float InverseDet = 1.0 / Det;

	float3 AO = Ray.Origin - Triangle.A;
	float U = dot(AO, PVector) * InverseDet;
	float3 QVector = cross(AO, Edge1);
	float V = dot(Ray.Direction, QVector) * InverseDet;
	float T = dot(Edge2, QVector) * InverseDet;

	HitInfo.bHit = Det > EPSILON && T > 0 && U >= 0 && V >= 0 && U + V <= 1;
	HitInfo.HitDistance = T;
	HitInfo.HitPosition = Ray.Origin + Ray.Direction * T;
	HitInfo.HitNormal = normalize(Triangle.NormalA * (1 - U - V) + Triangle.NormalB * U + Triangle.NormalC * V);
	// HitInfo.Material = Triangle.Material;
	
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FTriangleTest Triangle)
{
    FHitInfo HitInfo = (FHitInfo)0;

    const float EPSILON = 0.0000001;
    float3 Edge1 = Triangle.B - Triangle.A;
    float3 Edge2 = Triangle.C - Triangle.A;
    float3 PVector = cross(Ray.Direction, Edge2);
    float Det = dot(Edge1, PVector);

    float InverseDet = 1.0 / Det;

    float3 AO = Ray.Origin - Triangle.A;
    float U = dot(AO, PVector) * InverseDet;
    float3 QVector = cross(AO, Edge1);
    float V = dot(Ray.Direction, QVector) * InverseDet;
    float T = dot(Edge2, QVector) * InverseDet;

    HitInfo.bHit = Det > EPSILON && T > 0 && U >= 0 && V >= 0 && U + V <= 1;
    HitInfo.HitDistance = T;
    HitInfo.HitPosition = Ray.Origin + Ray.Direction * T;
    HitInfo.HitNormal = normalize(Triangle.NormalA * (1 - U - V) + Triangle.NormalB * U + Triangle.NormalC * V);
	
    return HitInfo;
}

bool RayBoundingBox(FRay Ray, float3 BoxMin, float3 BoxMax)
{
    float3 InvDir = 1.0 / Ray.Direction;
    float3 TMin = (BoxMin - Ray.Origin) * InvDir;
    float3 TMax = (BoxMax - Ray.Origin) * InvDir;

    float3 T1 = min(TMin, TMax);
    float3 T2 = max(TMin, TMax);

    float TNear = max(max(T1.x, T1.y), T1.z);
    float TFar = min(min(T2.x, T2.y), T2.z);

    return TNear <= TFar && TFar >= 0;
}

FHitInfo HitScene(FRay Ray, FPlane Plane)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

// FHitInfo HitScene(FRay Ray, FSphere Spheres[NUM_SPHERE])
// {
//     FHitInfo HitInfo = (FHitInfo)0;
//     HitInfo.bHit = false;
//     HitInfo.HitDistance = INFINITE_FLOAT;
//
//     for (int i = 0; i < NUM_SPHERE; i++)
//     {
//         FHitInfo LocalHit = HitScene(Ray, Spheres[i]);
//         if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
//         {
//             HitInfo = LocalHit;
//         }
//     }
    // for (int i = 0; i < NUM_QUAD; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Quads[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_TRIANGLE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Triangles[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_PLANE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Planes[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // return HitInfo;
// }

FHitInfo RayCollision(FRay Ray)
{
	FTriangleTest Triangles[2];
	Triangles[0].A = float3(-50,  50, 0);
	Triangles[0].B = float3( 50, -50, 0);
	Triangles[0].C = float3( 50,  50, 0);
	Triangles[0].NormalA = float3(0, 0, 1);
	Triangles[0].NormalB = float3(0, 0, 1);
	Triangles[0].NormalC = float3(0, 0, 1);
	Triangles[0].Material = LAMBERT(float3(0.9, 0.1, 0.9));
	
	Triangles[1].A = float3( 50, -50, 0);
	Triangles[1].B = float3(-50,  50, 0);
	Triangles[1].C = float3(-50,  -50, 0);
	Triangles[1].NormalA = float3(0, 0, 1);
	Triangles[1].NormalB = float3(0, 0, 1);
	Triangles[1].NormalC = float3(0, 0, 1);
	Triangles[1].Material = METAL(float3(0.9, 0.9, 0.1), 1.0);
	
    FHitInfo HitInfo = (FHitInfo)0;
    HitInfo.HitDistance = INFINITE_FLOAT;

    // for (int i = 0; i < NumMeshes; i++)
    // {
    //     FRTMeshRenderData Mesh = RTRenderDataBuffer[i];
    //     FHitInfo LocalHit = HitScene(Ray, Mesh.Position, Mesh.Radius);
    //
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //         HitInfo.Material = Mesh.Material;
    //     }
    // }
    
	for (int i = 0; i < 2; i++)
	{
		FHitInfo LocalHit = HitScene(Ray, Triangles[i]);
		if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
		{
			HitInfo = LocalHit;
			HitInfo.Material = Triangles[i].Material;
		}
	}
    
    // for (int MeshIndex = 0; MeshIndex < NumMeshes; MeshIndex++)
    // {
    //     FMeshInfo MeshInfo = RTMeshInfoBuffer[MeshIndex];
    //     if (!RayBoundingBox(Ray, MeshInfo.BoundMin, MeshInfo.BoundMax))
    //     {
    //         continue;
    //     }
    //     for (uint i = 0; i < MeshInfo.NumTriangles; i++)
    //     {
    //         int TriIndex = MeshInfo.FirstTriangleIdx + i;
    //         FTriangle Triangle = RTTriangleBuffer[TriIndex];
    //         FHitInfo LocalHit = HitScene(Ray, Triangle);
    //         if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance)
    //         {
    //             HitInfo = LocalHit;
    //             HitInfo.Material = MeshInfo.Material;
    //         }
    //     }
    // }
    
    return HitInfo;
}

float Schlick(float Cosine, float IOR)
{
	float R0 = (1.0 - IOR) / (1.0 + IOR);
	R0 = R0 * R0;
	return R0 + (1.0 - R0) * pow((1.0 - Cosine), 5);
}

float3 LightSample(FHitInfo HitInfo, FSphere Spheres[NUM_SPHERE])
{
    float3 Budge = 0;
    float MaxI = 0;
    for (int i = 0; i < NUM_SPHERE; i++)
    {
        if (Spheres[i].Material.Emission > 0)
        {
            float3 Dir = normalize(Spheres[i].Position - HitInfo.HitPosition);
            float Dp = dot(Dir, HitInfo.HitNormal);
            if (Dp > MaxI)
            {
                Budge = Dir;
                MaxI = Dp;
            }
        }
    }
    return Budge * MaxI * 2.0;
}

float3 TraceRay(FRay Ray, inout int RngState, TextureCube SkyCube, SamplerState CubeSampler)
{
    // SkyColor = 0.1 * (1 + Ray.Direction.z ) * float3(0.5, 0.7, 1.0);

	float3 IncomingLight = 0;
	float3 RayColor = 1;
	float3 FinalColor = 1;

    for (int i = 0; i < MAX_BOUNCE; i++)
    {
        FHitInfo HitInfo = RayCollision(Ray);

        if (HitInfo.bHit)
        {
        	if (HitInfo.Material.Type == MAT_LIGHT)
        	{
        		FinalColor *= HitInfo.Material.Emission * HitInfo.Material.Albedo;
        		break;
        	}
        	if (HitInfo.Material.Type == MAT_DIFFUSE)
        	{
        		Ray.Origin = HitInfo.HitPosition;
        		Ray.Direction = HitInfo.HitNormal + RandomDirection(RngState);
        		FinalColor *= HitInfo.Material.Albedo;
        	}
        	if (HitInfo.Material.Type == MAT_METAL)
        	{
        		float3 DiffuseDir = normalize(HitInfo.HitNormal + RandomDirection(RngState));
        		float3 Reflected = reflect(Ray.Direction, HitInfo.HitNormal);
        		Ray.Origin = HitInfo.HitPosition;
        		Ray.Direction = normalize(lerp(DiffuseDir, Reflected, HitInfo.Material.Roughness));
        		FinalColor *= HitInfo.Material.Albedo;
        	}
        	if (HitInfo.Material.Type == MAT_DIALECTRIC)
        	{
        		float3 Reflected = reflect(Ray.Direction, HitInfo.HitNormal);
        		FinalColor = 1;
        		float3 Refracted = 0;
        		float3 OutNormal = 0;
        		float ReflectProb = 0;
        		float Cosine = 0;
        		float Eta;

        		float Dt = dot(Ray.Direction, HitInfo.HitNormal);

        		if (Dt > 0.0)
        		{
        			OutNormal = -HitInfo.HitNormal;
        			Eta = HitInfo.Material.RefractiveIndex;
        			Cosine = Eta * Dt / length(Ray.Direction);
        		}
        		else
        		{
        			OutNormal = HitInfo.HitNormal;
        			Eta = 1.0 / HitInfo.Material.RefractiveIndex;
        			Cosine = -Dt / length(Ray.Direction);
        		}
        		Refracted = refract(Ray.Direction, OutNormal, Eta);
        		if (all(Refracted))
				{
					ReflectProb = Schlick(Cosine, Eta);
				}
				else
				{
					ReflectProb = 1.0;
				}
        		if (RandomValue(RngState) < ReflectProb)
				{
					Ray.Origin = HitInfo.HitPosition;
					Ray.Direction = Reflected;
				}
				else
				{
					Ray.Origin = HitInfo.HitPosition;
					Ray.Direction = Refracted;
				}

        		FinalColor *= HitInfo.Material.Albedo;
        	}
        }
		else
		{
			float3 SkyColor = TextureCubeSample(SkyCube, CubeSampler, Ray.Direction).rgb;
		    // float3 SkyColor = 0.5 * (1 + Ray.Direction.z ) * float3(0.5, 0.7, 1.0);
			FinalColor *= SkyColor;
			break;
		}
    }
    return FinalColor;
}

