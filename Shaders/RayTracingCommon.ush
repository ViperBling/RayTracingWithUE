#pragma once

#include "RayTracingScene.ush"

#define SAMPLES_PER_PIXEL 1
#define MAX_BOUNCE 100

// PCG (permuted congruential generator). Thanks to:
// www.pcg-random.org and www.shadertoy.com/view/XlGcRh
uint NextRandom(inout uint State)
{
	State = State * 747796405 + 2891336453;
	uint result = ((State >> ((State >> 28) + 4)) ^ State) * 277803737;
	result = (result >> 22) ^ result;
	return result;
}

float RandomValue(inout uint State)
{
	return NextRandom(State) / 4294967295.0; // 2^32 - 1
}

// Random value in normal distribution (with mean=0 and sd=1)
float RandomValueNormalDistribution(inout uint State)
{
	// Thanks to https://stackoverflow.com/a/6178290
	float theta = 2 * 3.1415926 * RandomValue(State);
	float rho = sqrt(-2 * log(RandomValue(State)));
	return rho * cos(theta);
}

// Calculate a random direction
float3 RandomDirection(inout uint State)
{
	// Thanks to https://math.stackexchange.com/a/1585996
	float x = RandomValueNormalDistribution(State);
	float y = RandomValueNormalDistribution(State);
	float z = RandomValueNormalDistribution(State);
	return normalize(float3(x, y, z));
}

float2 RandomPointInCircle(inout uint RngState)
{
	float angle = RandomValue(RngState) * 2 * PI;
	float2 pointOnCircle = float2(cos(angle), sin(angle));
	return pointOnCircle * sqrt(RandomValue(RngState));
}

float ScalarTriple(float3 U, float3 V, float3 W)
{
	return dot(cross(U, V), W);
}

// SceneTest
FHitInfo HitScene(FRay Ray, FQuad Quad)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FSphere Sphere)
{
    FHitInfo NoHit = (FHitInfo)0;
    FHitInfo HitInfo = (FHitInfo)0;
    
    float3 OffsetRayOrigin = Ray.Origin - Sphere.Position;

    float a = dot(Ray.Direction, Ray.Direction);
    float b = dot(OffsetRayOrigin, Ray.Direction) * 2.0;
    float c = dot(OffsetRayOrigin, OffsetRayOrigin) - Sphere.Radius * Sphere.Radius;
    float Discriminant = b * b - 4.0 * a * c;

    if (Discriminant < 0.0001) return NoHit;

    float t = (-b - sqrt(Discriminant)) / 2.0 * a;
    if (t < 0.1)
    {
        t = (-b + sqrt(Discriminant)) / 2.0 * a;
    }
    if (t < 0.1) return NoHit;
    
    HitInfo.bHit = true;
    HitInfo.HitDistance = t;
    HitInfo.HitPosition = Ray.Origin + t * Ray.Direction;
    HitInfo.HitNormal = normalize(HitInfo.HitPosition - Sphere.Position);
    HitInfo.Material = Sphere.Material;
    
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FTriangle Triangle)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FPlane Plane)
{
    FHitInfo HitInfo = (FHitInfo)0;
    return HitInfo;
}

FHitInfo HitScene(FRay Ray, FSphere Spheres[NUM_SPHERE])
{
    FHitInfo HitInfo = (FHitInfo)0;
    HitInfo.HitDistance = INFINITE_FLOAT;

    for (int i = 0; i < NUM_SPHERE; i++)
    {
        FHitInfo LocalHit = HitScene(Ray, Spheres[i]);
        if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
        {
            HitInfo = LocalHit;
        }
    }
    // for (int i = 0; i < NUM_QUAD; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Quads[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_TRIANGLE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Triangles[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    // for (int i = 0; i < NUM_PLANE; i++)
    // {
    //     FHitInfo LocalHit = HitScene(Ray, Planes[i]);
    //     if (LocalHit.bHit && LocalHit.HitDistance < HitInfo.HitDistance && LocalHit.HitDistance > 0.0001)
    //     {
    //         HitInfo = LocalHit;
    //     }
    // }
    return HitInfo;
}

float3 LightSample(FHitInfo HitInfo, FSphere Spheres[NUM_SPHERE])
{
    float3 Budge = 0;
    float MaxI = 0;
    for (int i = 0; i < NUM_SPHERE; i++)
    {
        if (Spheres[i].Material.Emission > 0)
        {
            float3 Dir = normalize(Spheres[i].Position - HitInfo.HitPosition);
            float Dp = dot(Dir, HitInfo.HitNormal);
            if (Dp > MaxI)
            {
                Budge = Dir;
                MaxI = Dp;
            }
        }
    }
    return Budge * MaxI * 2.0;
}

float3 TraceRay(FRay Ray, inout int RngState)
{
    FSphere Spheres[NUM_SPHERE];
    InitScene(Spheres);

    const float3 SkyBoxColor = (1 + Ray.Direction.z ) * float3(0.5, 0.7, 1.0) * 10;
    
	float3 FinalColor = 1;

    for (int i = 0; i < MAX_BOUNCE; i++)
    {
        FHitInfo HitInfo = HitScene(Ray, Spheres);

        if (!HitInfo.bHit) return FinalColor * SkyBoxColor;

        if (HitInfo.Material.Emission > 0)
        {
            return HitInfo.Material.Emission * HitInfo.Material.Albedo;
        }

        Ray.Origin = HitInfo.HitPosition;

        // if (HitInfo.Material.RefractiveIndex > 0)
        // {
        //     bool bIsInside = dot(Ray.Direction, HitInfo.HitNormal) > 0;
        //     float RefractRate = bIsInside ? 1.0 / HitInfo.Material.RefractiveIndex : HitInfo.Material.RefractiveIndex;
        //
        //     float CosTheta = dot(-Ray.Direction, HitInfo.HitNormal);
        //     float SinTheta = sqrt(1 - CosTheta * CosTheta);
        //     bool bCantRefract = RefractRate * SinTheta > 1.0;
        //
        //     if (bCantRefract)
        //     {
        //         Ray.Direction = reflect(Ray.Direction, HitInfo.HitNormal);
        //     }
        //     else
        //     {
        //         Ray.Direction = refract(Ray.Direction, HitInfo.HitNormal, RefractRate);
        //     }
        //     continue;
        // }

        FinalColor *= HitInfo.Material.Albedo;

        float3 Reflected = reflect(Ray.Direction, HitInfo.HitNormal);
        float3 Scattered = normalize(HitInfo.HitPosition + RandomDirection(RngState) + HitInfo.HitNormal);
        float3 LightDir = LightSample(HitInfo, Spheres);
        float Bias = RandomValue(RngState);
        Scattered = lerp(Scattered, LightDir, Bias);
        Ray.Direction = normalize(lerp(Reflected, Scattered, HitInfo.Material.Fuzziness));
    }
    return FinalColor;
}

