#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "RayTracingCommon.ush"

RWTexture2D<float4> OutputUAV;

TextureCube SkyDomeCube;
SamplerState SkyDomeCubeSampler;

uint FrameCounter;

Texture2D LastFrameResult;
StructuredBuffer<FRTMeshRenderData> RTRenderDataBuffer;

Texture2D InRayTracingResult;

[numthreads(16, 16, 1)]
void RayTracingCS(
	int2 DispatchThreadID : SV_DispatchThreadID,
	uint3 GroupThreadID : SV_GroupThreadID)
{
	const uint2 ViewExtent = View.ViewSizeAndInvSize.xy;
	const uint2 PixelPos = DispatchThreadID.xy;
	const uint PixelIndex = PixelPos.y * ViewExtent.x + PixelPos.x;
    const float2 PixelSize = 1.0 / ViewExtent;
	// const float2 ScreenUV = (DispatchThreadID.xy + 0.5) * View.ViewSizeAndInvSize.zw;
    float2 ScreenUV = (DispatchThreadID.xy + 0.5) * PixelSize;
	const float AspectRatio = View.ViewSizeAndInvSize.z / View.ViewSizeAndInvSize.w;
	ResolvedView = ResolveView();
	
	uint RngState = PixelIndex + ResolvedView.FrameNumber * 719393;

    const float FOV = 90.0;
    float HalfWidth = tan(FOV * 0.5 * PI / 180.0);
    float HalfHeight = -HalfWidth * AspectRatio;

    // float3 Origin = float3(5, 1, 0);
    float3 Origin = LWCToFloat(ResolvedView.WorldCameraOrigin);
    // float3 LookAt = float3(0, 0, 0);
    // float3 Up = float3(0, 1, 0);
    float3 Up = View.ViewUp;

    // float3 Forward = normalize(Origin - LookAt);
    float3 Forward = -ResolvedView.ViewForward;
    float3 RightVector = normalize(cross(Forward, Up));
    float3 UpVector = cross(RightVector, Forward);

    float3 LowerLeft = Origin - HalfWidth * RightVector - HalfHeight * UpVector - Forward;
    float3 Horizontal = 2 * HalfWidth * RightVector;
    float3 Vertical = 2 * HalfHeight * UpVector;

    FRay Ray;
    float3 TotalIncomingLight = 0;

    float4 LastFrameSceneColor = LastFrameResult.Load(int3(PixelPos, 0));

    for (int i = 0; i < SAMPLES_PER_PIXEL; i++)
    {
        float3 Direction = LowerLeft - Origin;
        Direction += Horizontal * (PixelSize.x * frac(RandomValue(RngState)) + ScreenUV.x);
        Direction += Vertical * (PixelSize.y * frac(RandomValue(RngState)) + ScreenUV.y);

    	float2 DefocusJitter = RandomPointInCircle(RngState) * 0.5 / PixelPos.x;
        Ray.Origin = Origin + RightVector * DefocusJitter.x + UpVector * DefocusJitter.y;
    	
        Ray.Direction = normalize(Direction);

        TotalIncomingLight += TraceRay(Ray, RngState, SkyDomeCube, SkyDomeCubeSampler);
    }
    TotalIncomingLight /= SAMPLES_PER_PIXEL * 1.0;

    float FrameWeight = 1.0 / (FrameCounter + 1);
	TotalIncomingLight = saturate(lerp(LastFrameSceneColor.rgb, TotalIncomingLight, FrameWeight));
	
	OutputUAV[DispatchThreadID.xy] = float4(RTRenderDataBuffer[0].Material.Albedo.zzz, 1.0);
}

void RayTracingOutPS(
	float4 SvPosition : SV_POSITION,
	out float4 OutValue : SV_Target0
	)
{
    float4 CurrentFrameSceneColor = InRayTracingResult.Load(int3(SvPosition.xy, 0));
	OutValue = float4(saturate(CurrentFrameSceneColor).rgb, 1.0);
}